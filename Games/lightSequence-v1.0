/*
  MEMORY SEQUENCE (ESP32 + ILI9341 + XPT2046 + PN532 I2C + NeoPixel)

  ✅ Levels: EASY / MEDIUM / HARD
  ✅ Pick level -> countdown -> sequence plays -> user repeats with RFID
  ✅ Anti-double-read: WAIT_FOR_TAG -> WAIT_FOR_LIFT (stable no-tag)
  ✅ DONE screen button returns to LEVEL menu
  ✅ Coins are TOTAL (not reset every round). Score resets per session.
  ✅ INPUT timeout with shrinking bar:
     - if user doesn't scan in time -> whole board RED -> DONE (timeout)
  ✅ PN532 init retry screen (no freeze)
  ✅ Stable I2C: 100kHz + Wire timeout

  HW:
  - TFT CS = 15
  - Touch CS = 5, IRQ = 27 (set to 255 if noisy)
  - PN532 I2C: SDA=32 SCL=33
  - NeoPixel: pin 25, count 32
*/

#include <SPI.h>
#include <Wire.h>
#include <TFT_eSPI.h>
#include <XPT2046_Touchscreen.h>
#include <Adafruit_PN532.h>
#include <Adafruit_NeoPixel.h>

// ---------------- PINS ----------------
#define TFT_CS_PIN   15

#define TOUCH_CS     5
#define TOUCH_IRQ    27   // if IRQ is noisy, set to 255

#define PN532_SDA    32
#define PN532_SCL    33

#define LED_PIN      25
#define LED_COUNT    32

// ESP32 SPI pins (your wiring)
#define SPI_SCK_PIN  18
#define SPI_MISO_PIN 19
#define SPI_MOSI_PIN 23

// ---------------- OBJECTS ----------------
TFT_eSPI tft = TFT_eSPI();
XPT2046_Touchscreen ts(TOUCH_CS, TOUCH_IRQ);
Adafruit_PN532 nfc(-1, -1); // I2C, no IRQ/RST
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

// ---------------- SCREEN ----------------
static const int SCREEN_W = 320;
static const int SCREEN_H = 240;
static const uint8_t TFT_ROT = 1;
static const uint8_t TS_ROT  = 1;

// ---------------- TOUCH FILTER ----------------
static const int Z_MIN = 200;
static const int Z_MAX = 3800;
static uint32_t lastTouchMs = 0;

// Touch calibration (yours)
static int  TOUCH_X_MIN = 350;
static int  TOUCH_X_MAX = 3800;
static int  TOUCH_Y_MIN = 300;
static int  TOUCH_Y_MAX = 3800;

// If buttons act weird, toggle TOUCH_SWAP_XY
static bool TOUCH_SWAP_XY  = false;
static bool TOUCH_INVERT_X = true;
static bool TOUCH_INVERT_Y = false;

// ---------------- UI COLORS ----------------
const uint16_t C_BG     = 0x08A3;
const uint16_t C_PANEL2 = 0x18E7;
const uint16_t C_MUTED  = 0xBDF7;
const uint16_t C_ACCENT = 0x07FF; // cyan
const uint16_t C_OK     = 0x07E0; // green
const uint16_t C_BAD    = 0xF800; // red
const uint16_t C_WARN   = 0xFD20; // gold

// Sequence colors (PURPLE / BLUE / YELLOW)
uint32_t SEQ_COLORS[3];

// ---------------- LED ZONES ----------------
const uint8_t LED_ZONES[] = {0,2,4,6,9,11,13,15,16,18,20,22,25,27,29,31};
const int NUM_ZONES = sizeof(LED_ZONES) / sizeof(LED_ZONES[0]);

// ---------------- UID MAP ----------------
struct ZoneMap { uint8_t led; uint8_t uid[4]; };
ZoneMap MAP[] = {
  {0,{0x49,0x04,0x16,0xA4}}, {2,{0xC4,0x90,0x86,0xBB}},
  {4,{0x39,0x94,0xBB,0xA2}}, {6,{0x46,0xC2,0x86,0xBB}},
  {9,{0x79,0x78,0x21,0xA4}}, {11,{0x49,0xB3,0x25,0xA4}},
  {13,{0x79,0x69,0xCC,0xA2}}, {15,{0xB9,0xB7,0x84,0xC1}},
  {16,{0x89,0x74,0x85,0xC2}}, {18,{0x6B,0x8F,0xD5,0xAB}},
  {20,{0x89,0x59,0x23,0xA4}}, {22,{0x29,0xCF,0x38,0x59}},
  {25,{0xD9,0x60,0x22,0xA4}}, {27,{0x89,0xE9,0xC3,0xA2}},
  {29,{0x19,0xF7,0x80,0xC1}}, {31,{0x09,0xC3,0xCA,0xA2}}
};
const int MAP_LEN = sizeof(MAP) / sizeof(MAP[0]);

// ---------------- GAME STATE ----------------
enum Level { LV_NONE, LV_EASY, LV_MEDIUM, LV_HARD };
enum State { ST_RFID_RETRY, ST_PICK_LEVEL, ST_COUNTDOWN, ST_SHOW_SEQ, ST_INPUT_SEQ, ST_DONE };
enum InputPhase { WAIT_FOR_TAG, WAIT_FOR_LIFT };

Level level = LV_NONE;
State state = ST_RFID_RETRY;
InputPhase inputPhase = WAIT_FOR_TAG;

int score = 0;     // resets per session
int coins = 0;     // total coins (persistent across sessions)

static const int MAX_SEQ = 10;
uint8_t sequence[MAX_SEQ];

int seqBaseLen = 4;
int seqLen     = 4;
int userIndex  = 0;

uint16_t showOnMs  = 520;
uint16_t showGapMs = 240;

int noTagStreak = 0;
static const int LIFT_STREAK_REQUIRED = 4;

// ---------- INPUT TIMEOUT ----------
static const uint32_t INPUT_TIMEOUT_MS_EASY   = 12000; // 12s
static const uint32_t INPUT_TIMEOUT_MS_MEDIUM = 10000; // 10s
static const uint32_t INPUT_TIMEOUT_MS_HARD   = 8000;  // 8s
uint32_t lastUserActionMs = 0;

uint32_t inputTimeoutMs() {
  if(level == LV_EASY) return INPUT_TIMEOUT_MS_EASY;
  if(level == LV_MEDIUM) return INPUT_TIMEOUT_MS_MEDIUM;
  return INPUT_TIMEOUT_MS_HARD;
}
void resetInputTimer() { lastUserActionMs = millis(); }

// ---------- TIMEOUT BAR UI ----------
static const int BAR_X = 40;
static const int BAR_Y = 30;   // under title
static const int BAR_W = 240;
static const int BAR_H = 10;
uint32_t lastBarDrawMs = 0;
int lastBarFill = -1;

// ---------------- HELPERS ----------------
static int clampi(int v, int lo, int hi){ if(v<lo) return lo; if(v>hi) return hi; return v; }

void ledsOff() { strip.clear(); strip.show(); }

void lightOne(uint8_t idx, uint32_t c) {
  strip.clear();
  strip.setPixelColor(idx, c);
  strip.show();
}

void fillAll(uint32_t c) {
  for(int i=0;i<LED_COUNT;i++) strip.setPixelColor(i, c);
  strip.show();
}

void flashAll(uint32_t c, int times, int onMs=120, int offMs=80) {
  for(int t=0;t<times;t++){
    fillAll(c); delay(onMs);
    ledsOff();  delay(offMs);
  }
}

// Small “kick” for PN532 (NOT every loop)
void kickPN532() {
  nfc.SAMConfig();
}

// ---------------- TOUCH ----------------
bool readTouchRaw(TS_Point &out) {
  digitalWrite(TFT_CS_PIN, HIGH);

  if (TOUCH_IRQ != 255 && digitalRead(TOUCH_IRQ) == HIGH) return false;

  TS_Point best(0,0,0);
  for(int i=0;i<6;i++){
    TS_Point p = ts.getPoint();
    if(p.z > best.z) best = p;
    delay(2);
  }
  if(best.z < Z_MIN || best.z > Z_MAX) return false;
  out = best;
  return true;
}

bool rawToScreen(const TS_Point &raw, int &sx, int &sy) {
  int rx = raw.x, ry = raw.y;
  if(TOUCH_SWAP_XY) { int tmp=rx; rx=ry; ry=tmp; }

  rx = clampi(rx, TOUCH_X_MIN, TOUCH_X_MAX);
  ry = clampi(ry, TOUCH_Y_MIN, TOUCH_Y_MAX);

  long nx = (long)(rx - TOUCH_X_MIN) * (SCREEN_W - 1) / (TOUCH_X_MAX - TOUCH_X_MIN);
  long ny = (long)(ry - TOUCH_Y_MIN) * (SCREEN_H - 1) / (TOUCH_Y_MAX - TOUCH_Y_MIN);

  if(TOUCH_INVERT_X) nx = (SCREEN_W - 1) - nx;
  if(TOUCH_INVERT_Y) ny = (SCREEN_H - 1) - ny;

  sx = (int)nx; sy = (int)ny;
  return true;
}

bool touchDebounced(int &sx, int &sy, TS_Point *rawOut=nullptr) {
  TS_Point raw;
  if(!readTouchRaw(raw)) return false;
  if(millis() - lastTouchMs < 220) return false;
  lastTouchMs = millis();

  if(rawOut) *rawOut = raw;
  return rawToScreen(raw, sx, sy);
}

// ---------------- RFID ----------------
bool readUID4(uint8_t out[4]) {
  uint8_t uid[7], len;
  if(!nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &len, 40)) return false;
  if(len < 4) return false;
  for(int i=0;i<4;i++) out[i] = uid[i];
  return true;
}

const uint8_t* expectedUIDForLed(uint8_t led){
  for(int i=0;i<MAP_LEN;i++) if(MAP[i].led == led) return MAP[i].uid;
  return nullptr;
}

bool uidEq(const uint8_t*a,const uint8_t*b){
  for(int i=0;i<4;i++) if(a[i]!=b[i]) return false;
  return true;
}

bool initPN532Once() {
  nfc.begin();
  delay(30);
  uint32_t v = nfc.getFirmwareVersion();
  if(!v) return false;
  nfc.SAMConfig();
  return true;
}

bool initPN532WithFallback() {
  Wire.setClock(100000);   // stable for PN532
  Wire.setTimeOut(50);     // prevent I2C hanging forever (ESP32 Wire)
  return initPN532Once();
}

// ---------------- UI ----------------
uint16_t blend565(uint16_t c1, uint16_t c2, uint8_t t) {
  uint8_t r1 = (c1 >> 11) & 0x1F, g1 = (c1 >> 5) & 0x3F, b1 = c1 & 0x1F;
  uint8_t r2 = (c2 >> 11) & 0x1F, g2 = (c2 >> 5) & 0x3F, b2 = c2 & 0x1F;
  uint8_t r = (r1*(255-t) + r2*t)/255;
  uint8_t g = (g1*(255-t) + g2*t)/255;
  uint8_t b = (b1*(255-t) + b2*t)/255;
  return (r<<11) | (g<<5) | b;
}

void fillGradV(int x, int y, int w, int h, uint16_t top, uint16_t bot, int step=2) {
  for(int i=0;i<h;i+=step){
    uint8_t t = (uint32_t)i * 255 / (h - 1);
    uint16_t c = blend565(top, bot, t);
    tft.fillRect(x, y+i, w, step, c);
  }
}

void drawBackground() {
  fillGradV(0,0,SCREEN_W,SCREEN_H, C_BG, 0x0008, 2);
  for(int i=0;i<18;i++) tft.drawPixel(random(0,SCREEN_W), random(0,SCREEN_H), TFT_WHITE);
}

void drawTopTitle(const char* title) {
  tft.setTextDatum(MC_DATUM);
  tft.setTextFont(2);
  tft.setTextColor(C_MUTED, TFT_BLACK);
  tft.drawString(title, 160, 18);
  tft.setTextDatum(TL_DATUM);
}

// ---------------- UI LAYOUT ----------------
static const int CARD_X = 30;
static const int CARD_Y = 44;
static const int CARD_W = 260;
static const int CARD_H = 42;

static const int BTN_X = 20;
static const int BTN_W = 280;
static const int BTN_H = 36;

static const int BTN_EASY_Y = 96;
static const int BTN_MED_Y  = 140;
static const int BTN_HARD_Y = 184;

static const int BTN_RETRY_X = 80;
static const int BTN_RETRY_Y = 168;
static const int BTN_RETRY_W = 160;
static const int BTN_RETRY_H = 46;

void uiButton(int x,int y,int w,int h,uint16_t bg,const char* label) {
  tft.fillRoundRect(x+3,y+3,w,h,16,TFT_BLACK);
  tft.fillRoundRect(x,y,w,h,16,bg);
  tft.drawRoundRect(x,y,w,h,16,TFT_WHITE);

  tft.setTextDatum(MC_DATUM);
  tft.setTextFont(4);
  tft.setTextColor(TFT_BLACK, bg);
  tft.drawString(label, x+w/2+1, y+h/2+1);
  tft.setTextColor(TFT_WHITE, bg);
  tft.drawString(label, x+w/2, y+h/2);
  tft.setTextDatum(TL_DATUM);
}

void drawCenterCard(const char* top, const char* bottom) {
  tft.fillRoundRect(CARD_X+3, CARD_Y+3, CARD_W, CARD_H, 14, TFT_BLACK);
  tft.fillRoundRect(CARD_X,   CARD_Y,   CARD_W, CARD_H, 14, C_PANEL2);
  tft.drawRoundRect(CARD_X,   CARD_Y,   CARD_W, CARD_H, 14, TFT_WHITE);

  tft.setTextDatum(MC_DATUM);

  tft.setTextFont(2);
  tft.setTextColor(C_ACCENT, C_PANEL2);
  tft.drawString(top, 160, CARD_Y + 14);

  tft.setTextFont(1);
  tft.setTextColor(TFT_WHITE, C_PANEL2);
  tft.drawString(bottom, 160, CARD_Y + 28);

  tft.setTextDatum(TL_DATUM);
}

// --------- Timeout bar drawing ----------
void drawTimeoutBarFrame() {
  tft.drawRoundRect(BAR_X, BAR_Y, BAR_W, BAR_H, 4, TFT_WHITE);
  tft.fillRoundRect(BAR_X+1, BAR_Y+1, BAR_W-2, BAR_H-2, 3, TFT_BLACK);
  lastBarFill = -1;
  lastBarDrawMs = 0;
}

void updateTimeoutBar() {
  if(state != ST_INPUT_SEQ) return;
  if(millis() - lastBarDrawMs < 120) return;
  lastBarDrawMs = millis();

  uint32_t tmo = inputTimeoutMs();
  uint32_t elapsed = millis() - lastUserActionMs;
  if(elapsed > tmo) elapsed = tmo;

  int fillPx = (int)((uint32_t)(BAR_W-2) * (tmo - elapsed) / tmo);
  if(fillPx == lastBarFill) return;
  lastBarFill = fillPx;

  tft.fillRoundRect(BAR_X+1, BAR_Y+1, BAR_W-2, BAR_H-2, 3, TFT_BLACK);
  if(fillPx > 0) {
    tft.fillRoundRect(BAR_X+1, BAR_Y+1, fillPx, BAR_H-2, 3, C_ACCENT);
  }
}

// ---------------- SCREENS ----------------
void drawRfidRetryScreen() {
  ledsOff();
  drawBackground();
  drawTopTitle("Memory Sequence");
  drawCenterCard("RFID ERROR", "Tap RETRY to reconnect");
  uiButton(BTN_RETRY_X, BTN_RETRY_Y, BTN_RETRY_W, BTN_RETRY_H, C_WARN, "RETRY");
}

void drawLevelScreen() {
  ledsOff();
  drawBackground();
  drawTopTitle("Memory Sequence");
  drawCenterCard("Choose Difficulty", "Tap to start");
  uiButton(BTN_X, BTN_EASY_Y, BTN_W, BTN_H, C_OK,   "EASY");
  uiButton(BTN_X, BTN_MED_Y,  BTN_W, BTN_H, C_WARN, "MEDIUM");
  uiButton(BTN_X, BTN_HARD_Y, BTN_W, BTN_H, C_BAD,  "HARD");
}

void drawRepeatScreen() {
  drawBackground();
  drawTopTitle("Your turn");
  drawCenterCard("REPEAT", "Scan tags in the same order");
}

void drawDoneScreen(bool win, bool timedOut=false) {
  ledsOff();
  drawBackground();

  tft.setTextDatum(MC_DATUM);
  tft.setTextFont(4);

  if(win) {
    tft.setTextColor(C_OK, TFT_BLACK);
    tft.drawString("NICE!", 160, 42);
  } else {
    tft.setTextColor(C_BAD, TFT_BLACK);
    tft.drawString(timedOut ? "TIME!" : "OOPS!", 160, 42);
  }

  int msgY = 74;
  tft.fillRoundRect(30, msgY, 260, 44, 14, C_PANEL2);
  tft.drawRoundRect(30, msgY, 260, 44, 14, TFT_WHITE);

  tft.setTextFont(2);
  tft.setTextColor(TFT_WHITE, C_PANEL2);

  if(win) {
    tft.drawString("You completed the sequence", 160, msgY + 22);
  } else if(timedOut) {
    tft.drawString("No scan detected in time", 160, msgY + 22);
  } else {
    tft.drawString("You missed the sequence", 160, msgY + 22);
  }

  tft.setTextColor(C_MUTED, TFT_BLACK);
  tft.drawString(String("Score: ") + score + "   Coins: " + coins, 160, 132);

  uiButton(60, 160, 200, 44, C_ACCENT, "TRY AGAIN");

  tft.setTextDatum(TL_DATUM);
}

// ---------------- SEQUENCE ----------------
uint8_t pickZoneNotSame(uint8_t prev) {
  uint8_t led;
  do { led = LED_ZONES[random(NUM_ZONES)]; } while(led == prev && NUM_ZONES > 1);
  return led;
}

void generateSequence(int len) {
  uint8_t prev = 255;
  for(int i=0;i<len;i++){
    sequence[i] = pickZoneNotSame(prev);
    prev = sequence[i];
  }
}

void applyLevelSettings() {
  if(level == LV_EASY){
    seqBaseLen = 3;
    showOnMs = 540; showGapMs = 250;
  } else if(level == LV_MEDIUM){
    seqBaseLen = 4;
    showOnMs = 430; showGapMs = 210;
  } else {
    seqBaseLen = 5;
    showOnMs = 330; showGapMs = 170;
  }
}

void startNewRound() {
  seqLen = seqBaseLen;
  userIndex = 0;
  inputPhase = WAIT_FOR_TAG;
  noTagStreak = 0;
  generateSequence(seqLen);
  resetInputTimer();
}

void doCountdown() {
  drawBackground();
  drawTopTitle("Get ready");
  drawCenterCard("STARTING", "Watch closely...");

  for(int n=3; n>=1; n--){
    int x=70, y=96, w=180, h=84;
    tft.fillRoundRect(x+3,y+3,w,h,16,TFT_BLACK);
    tft.fillRoundRect(x,y,w,h,16,C_PANEL2);
    tft.drawRoundRect(x,y,w,h,16,TFT_WHITE);

    tft.setTextDatum(MC_DATUM);
    tft.setTextFont(8);
    tft.setTextColor(TFT_WHITE, C_PANEL2);
    tft.drawString(String(n), 160, 138);
    tft.setTextDatum(TL_DATUM);

    flashAll(strip.Color(0,120,180), 1, 70, 70);
    delay(650);

    drawBackground();
    drawTopTitle("Get ready");
    drawCenterCard("STARTING", "Watch closely...");
  }

  state = ST_SHOW_SEQ;
}

void showSequence() {
  drawBackground();
  drawTopTitle("Watch the sequence");
  drawCenterCard("WATCH", "Then repeat with RFID");
  delay(300);

  for(int i=0;i<seqLen;i++){
    uint8_t led = sequence[i];
    uint32_t c  = SEQ_COLORS[i % 3];
    lightOne(led, c);
    delay(showOnMs);
    ledsOff();
    delay(showGapMs);
  }

  userIndex = 0;
  inputPhase = WAIT_FOR_TAG;
  noTagStreak = 0;

  drawRepeatScreen();
  drawTimeoutBarFrame();

  state = ST_INPUT_SEQ;
  kickPN532();
  resetInputTimer();
}

// ---------------- INPUT ----------------
void feedbackForStep(bool ok, uint8_t led) {
  if(ok){
    lightOne(led, strip.Color(0,180,0));
    delay(160);
    ledsOff();
  } else {
    fillAll(strip.Color(180,0,0));
    delay(450);
    ledsOff();
  }
}

int pointsPerStep() {
  if(level == LV_EASY) return 1;
  if(level == LV_MEDIUM) return 2;
  return 3; // HARD
}

int winBonus() {
  if(level == LV_EASY) return 5;
  if(level == LV_MEDIUM) return 8;
  return 12; // HARD
}

int coinsReward() {
  if(level == LV_EASY) return 1;
  if(level == LV_MEDIUM) return 2;
  return 3; // HARD
}

void handleInputSequence() {
  // ✅ timeout (no scans)
  if(millis() - lastUserActionMs > inputTimeoutMs()) {
    fillAll(strip.Color(180,0,0));
    delay(450);
    ledsOff();

    state = ST_DONE;
    drawDoneScreen(false, true);
    return;
  }

  uint8_t uid4[4];
  bool tagPresent = readUID4(uid4);

  if(inputPhase == WAIT_FOR_TAG) {
    if(!tagPresent) return;

    resetInputTimer(); // ✅ user did something

    uint8_t expectedLed = sequence[userIndex];
    const uint8_t* expUid = expectedUIDForLed(expectedLed);
    bool correct = (expUid && uidEq(uid4, expUid));

    feedbackForStep(correct, expectedLed);

    inputPhase = WAIT_FOR_LIFT;
    noTagStreak = 0;

    if(!correct) {
      state = ST_DONE;
      drawDoneScreen(false, false);
      return;
    }

    score += pointsPerStep();
    userIndex++;

    if(userIndex >= seqLen) {
      fillAll(strip.Color(0,180,0));
      delay(450);
      ledsOff();

      score += winBonus();
      coins += coinsReward();   // ✅ total coins

      state = ST_DONE;
      drawDoneScreen(true, false);
      return;
    }
    return;
  }

  // WAIT_FOR_LIFT
  if(tagPresent) { noTagStreak = 0; return; }

  noTagStreak++;
  if(noTagStreak >= LIFT_STREAK_REQUIRED) {
    inputPhase = WAIT_FOR_TAG;
    noTagStreak = 0;
    kickPN532();
  }
}

// ---------------- SETUP / LOOP ----------------
void setup() {
  Serial.begin(115200);
  delay(150);
  randomSeed(micros());

  pinMode(TFT_CS_PIN, OUTPUT);
  digitalWrite(TFT_CS_PIN, HIGH);

  pinMode(TOUCH_CS, OUTPUT);
  digitalWrite(TOUCH_CS, HIGH);

  if(TOUCH_IRQ != 255) pinMode(TOUCH_IRQ, INPUT);

  SPI.begin(SPI_SCK_PIN, SPI_MISO_PIN, SPI_MOSI_PIN);

  tft.init();
  tft.setRotation(TFT_ROT);
  tft.setTextWrap(false);

  ts.begin();
  ts.setRotation(TS_ROT);

  strip.begin();
  ledsOff();

  SEQ_COLORS[0] = strip.Color(160, 0, 255);
  SEQ_COLORS[1] = strip.Color(0, 120, 255);
  SEQ_COLORS[2] = strip.Color(220, 170, 0);

  Wire.begin(PN532_SDA, PN532_SCL);
  Wire.setClock(100000);
  Wire.setTimeOut(50);

  if(initPN532WithFallback()) {
    state = ST_PICK_LEVEL;
    drawLevelScreen();
  } else {
    state = ST_RFID_RETRY;
    drawRfidRetryScreen();
  }
}

void loop() {
  int sx, sy;

  // RFID RETRY
  if(state == ST_RFID_RETRY) {
    if(touchDebounced(sx, sy)) {
      bool inRetry =
        (sx >= BTN_RETRY_X && sx <= BTN_RETRY_X + BTN_RETRY_W &&
         sy >= BTN_RETRY_Y && sy <= BTN_RETRY_Y + BTN_RETRY_H);

      if(inRetry) {
        drawCenterCard("RETRYING...", "Please wait");
        if(initPN532WithFallback()) {
          state = ST_PICK_LEVEL;
          drawLevelScreen();
        } else {
          drawRfidRetryScreen();
        }
      }
    }
    delay(20);
    return;
  }

  // PICK LEVEL
  if(state == ST_PICK_LEVEL) {
    if(touchDebounced(sx, sy)) {
      bool inEasy =
        (sx >= BTN_X && sx <= BTN_X + BTN_W &&
         sy >= BTN_EASY_Y && sy <= BTN_EASY_Y + BTN_H);

      bool inMed  =
        (sx >= BTN_X && sx <= BTN_X + BTN_W &&
         sy >= BTN_MED_Y && sy <= BTN_MED_Y + BTN_H);

      bool inHard =
        (sx >= BTN_X && sx <= BTN_X + BTN_W &&
         sy >= BTN_HARD_Y && sy <= BTN_HARD_Y + BTN_H);

      if(inEasy)      level = LV_EASY;
      else if(inMed)  level = LV_MEDIUM;
      else if(inHard) level = LV_HARD;
      else { delay(10); return; }  // outside buttons

      applyLevelSettings();
      score = 0;                  // ✅ reset session score only
      coins = 0;


      startNewRound();
      state = ST_COUNTDOWN;
      doCountdown();
    }

    delay(10);
    return;
  }

  // SHOW SEQUENCE
  if(state == ST_SHOW_SEQ) { showSequence(); delay(10); return; }

  // INPUT
  if(state == ST_INPUT_SEQ) {
    updateTimeoutBar();
    handleInputSequence();
    delay(5);
    return;
  }

  // DONE -> back to LEVEL MENU
  if(state == ST_DONE) {
    if(touchDebounced(sx, sy)) {
      bool inTryAgain =
        (sx >= 60 && sx <= 60 + 200 &&
         sy >= 160 && sy <= 160 + 44);

      bool inCenterCard =
        (sx >= 30 && sx <= 30 + 260 &&
         sy >= 74 && sy <= 74 + 44);

      if(inTryAgain || inCenterCard) {
        level = LV_NONE;
        userIndex = 0;
        noTagStreak = 0;

        state = ST_PICK_LEVEL;
        drawLevelScreen();
      }
    }

    delay(20);
    return;
  }

  delay(10);
}
